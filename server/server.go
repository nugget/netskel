package main

import (
	"crypto/md5"
	"crypto/rand"
	"crypto/rsa"
	"crypto/x509"
	"encoding/base64"
	"encoding/pem"
	"fmt"
	"io"
	"io/ioutil"
	"os"
	"strconv"
	"strings"
	"time"

	"github.com/blackjack/syslog"
	"github.com/boltdb/bolt"
	"github.com/satori/go.uuid"
	"golang.org/x/crypto/ssh"
)

var (
	AUTHKEYSFILE string = os.Getenv("HOME") + "/.ssh/authorized_keys"
	CLIENT       string = strings.Split(os.Getenv("SSH_CLIENT"), " ")[0]
	UUID         string
	USERNAME     string
	HOSTNAME     string
)

func Debug(format string, a ...interface{}) {
	syslog.Syslogf(syslog.LOG_DEBUG, format, a...)
}

func Log(format string, a ...interface{}) {
	syslog.Syslogf(syslog.LOG_NOTICE, format, a...)
}

func Warn(format string, a ...interface{}) {
	syslog.Syslogf(syslog.LOG_WARNING, format, a...)
}

func syntaxError() {
	fmt.Println("ERROR")
	os.Exit(1)
}

func dbFileLine(filename string) {
	file, err := os.Stat(filename)
	if err != nil {
		Warn("Error Stat %v: %v", filename, err)
		return
	}

	trimmed := strings.TrimPrefix(filename, "./")

	hash, _ := fingerprint(filename)

	mode := 0600
	if file.Mode()&0111 != 0 {
		mode = 0700
	}

	fmt.Printf("%s\t%o\t*\t%d\t%x\n", trimmed, mode, file.Size(), hash)
}

func dbDirLine(directory string) {
	trimmed := strings.TrimPrefix(directory, "./")
	fmt.Printf("%s/\t%d\t*\n", trimmed, 700)
}

func listDir(dirname string) {
	files, err := ioutil.ReadDir(dirname)
	if err != nil {
		Warn("Error reading directory %v", dirname)
		return
	}

	for _, file := range files {
		if file.Name() == ".git" {
			continue
		}

		fullname := dirname + "/" + file.Name()

		switch mode := file.Mode(); {
		case mode.IsDir():
			dbDirLine(fullname)
			listDir(fullname)
		case mode.IsRegular():
			dbFileLine(fullname)
		}
	}
}

func netskelDB() {
	servername, _ := os.Hostname()
	now := time.Now().Format("Mon, 2 Jan 2006 15:04:05 UTC")

	fmt.Printf("#\n# .netskeldb for %s at %v\n#\n# Generated %v by %v\n#\n", UUID, CLIENT, now, servername)

	// Force-inject the client itself
	dbDirLine("bin")
	dbFileLine("bin/netskel")

	os.Chdir("db")
	listDir(".")

	Log("Sent netskeldb to %s@%s at %s (%s)", USERNAME, HOSTNAME, CLIENT, UUID)
}

func fingerprint(filename string) ([]byte, error) {
	var result []byte

	file, err := os.Open(filename)
	if err != nil {
		return result, err
	}
	defer file.Close()

	hash := md5.New()
	if _, err := io.Copy(hash, file); err != nil {
		return result, err
	}

	return hash.Sum(result), nil
}

func sendBase64(filename string) {
	linelength := 76
	count := 0

	file, err := ioutil.ReadFile(filename)
	if err != nil {
		Warn("Error trying to base64 %v: %v", filename, err)
		os.Exit(1)
	}

	str := base64.StdEncoding.EncodeToString(file)

	for _, c := range str {
		fmt.Printf("%c", c)
		count += 1
		if count >= linelength {
			count = 0
			fmt.Printf("\n")
		}
	}
	fmt.Printf("\n")

	Log("Sent base64  %s (%d bytes) to %s@%s at %s (%s)", filename, len(file), USERNAME, HOSTNAME, CLIENT, UUID)
}

func sendHexdump(filename string) {
	linelength := 30
	count := 0

	file, err := ioutil.ReadFile(filename)
	if err != nil {
		Warn("Error trying to hexdump %v: %v", filename, err)
		os.Exit(1)
	}

	for _, c := range file {
		fmt.Printf("%02x", c)
		count += 1
		if count >= linelength {
			count = 0
			fmt.Printf("\n")
		}
	}
	fmt.Printf("\n")
	Log("Sent hexdump %s (%d bytes) to %s@%s at %s (%s)", filename, len(file), USERNAME, HOSTNAME, CLIENT, UUID)
}

func sendRaw(filename string) {
	file, err := ioutil.ReadFile(filename)
	if err != nil {
		Warn("Error trying to sendRaw %v: %v", filename, err)
		os.Exit(1)
	}
	fmt.Printf("%v", string(file))
	os.Exit(0)
}

func addKey() {
	servername, err := os.Hostname()
	now := time.Now()
	nowFmt := now.Format("Mon Jan _2 15:04:05 2006")
	uuid, _ := uuid.NewV4()
	cuuid := uuid.String()

	privateKey, err := rsa.GenerateKey(rand.Reader, 2048)
	if err != nil {
		Warn("Error generating private key: %v", err)
		os.Exit(1)
	}
	privateKeyPEM := &pem.Block{Type: "RSA PRIVATE KEY", Bytes: x509.MarshalPKCS1PrivateKey(privateKey)}
	pemdata := pem.EncodeToMemory(privateKeyPEM)

	pub, err := ssh.NewPublicKey(&privateKey.PublicKey)
	if err != nil {
		Warn("Error constructing public key: %v", err)
		os.Exit(1)
	}
	pubdata := strings.TrimSpace(string(ssh.MarshalAuthorizedKey(pub)))

	f, err := os.OpenFile(AUTHKEYSFILE, os.O_APPEND|os.O_WRONLY, 0600)
	if err != nil {
		Warn("Error opening %s for writing: %v", AUTHKEYSFILE, err)
		os.Exit(1)
	}

	defer f.Close()

	if _, err = f.WriteString("restrict " + pubdata + " " + HOSTNAME + " " + cuuid + " " + nowFmt + "\n"); err != nil {
		panic(err)
	}

	fmt.Printf("#\n# Netskel private key generated by %v for %v (%v)\n#\n", servername, HOSTNAME, CLIENT)
	fmt.Printf("# CLIENT_UUID %s\n#\n", uuid)
	fmt.Println(string(pemdata))

	secs := strconv.Itoa(int(now.Unix()))

	clientPut(cuuid, "hostname", HOSTNAME)
	clientPut(cuuid, "originalHostname", HOSTNAME)
	clientPut(cuuid, "created", secs)

	Log("Added %d byte public key to %s for %s@%s (%v) uuid %s", len(pubdata), AUTHKEYSFILE, USERNAME, HOSTNAME, CLIENT, uuid)
}

func clientHeartbeat() {
	now := time.Now()
	secs := strconv.Itoa(int(now.Unix()))

	clientPut(UUID, "inet", CLIENT)
	clientPut(UUID, "lastSeen", secs)
	clientPut(UUID, "hostname", HOSTNAME)
	clientPut(UUID, "username", USERNAME)

	Debug("Stored heartbeat for %v", UUID)
}

func clientPut(uuid, key, value string) {
	db, err := bolt.Open("clients.db", 0660, &bolt.Options{Timeout: 2 * time.Second})
	if err != nil {
		Warn("Unable to open client database: %v", err)
		return
	}
	defer db.Close()

	berr := db.Update(func(tx *bolt.Tx) error {
		b, err := tx.CreateBucketIfNotExists([]byte(uuid))
		if err != nil {
			return fmt.Errorf("Can't create bucket for %s: %v", uuid, err)
		}

		perr := b.Put([]byte(key), []byte(value))
		return perr
	})

	if berr != nil {
		Warn("clientPut error %v", berr)
	}
}

func parseUNH(nsCommand []string, uuidPosition, usernamePosition, hostnamePosition int) (string, string, string) {
	cuuid := "nouuid"
	username := "user"
	hostname := "unknown"

	if len(nsCommand) > uuidPosition {
		c, err := uuid.FromString(nsCommand[uuidPosition])
		if err != nil {
			Warn("Unable to parse client-supplied UUID %v: %v", nsCommand[uuidPosition], err)
		} else {
			cuuid = c.String()
		}
	}

	if len(nsCommand) > usernamePosition {
		username = nsCommand[usernamePosition]
	}

	if len(nsCommand) > hostnamePosition {
		hostname = nsCommand[hostnamePosition]
	}

	return cuuid, username, hostname
}

func main() {
	syslog.Openlog("netskel-server", syslog.LOG_PID, syslog.LOG_USER)

	if os.Args[0] != "server" {
		syntaxError()
	}

	nsCommand := strings.Split(os.Args[2], " ")
	command := nsCommand[0]

	Debug("Launched from %v with %v", CLIENT, nsCommand)

	switch command {
	case "netskeldb":
		UUID, USERNAME, HOSTNAME = parseUNH(nsCommand, 1, 2, 3)

		clientHeartbeat()
		netskelDB()

	case "md5":
		filename := nsCommand[1]
		hash, _ := fingerprint(filename)
		fmt.Println(hash)

	case "sendfile":
		filename := nsCommand[1]
		UUID, USERNAME, HOSTNAME = parseUNH(nsCommand, 2, 3, 4)

		if filename == "db/bin/netskel" {
			filename = "bin/netskel"
		}

		sendHexdump(filename)

	case "sendbase64":
		filename := nsCommand[1]
		UUID, USERNAME, HOSTNAME = parseUNH(nsCommand, 2, 3, 4)

		if filename == "db/bin/netskel" {
			filename = "bin/netskel"
		}

		sendBase64(filename)

	case "rawclient":
		filename := "bin/netskel"
		sendRaw(filename)

	case "addkey":
		_, USERNAME, HOSTNAME = parseUNH(nsCommand, 1, 2, 3)
		addKey()

	default:
		syntaxError()
	}

	os.Exit(0)
}
